/*
 * q3entity - Convert entity JSON to Quake 3 .map entity definitions
 * Part of BioMimetic AI spatial twin fast regeneration system
 */

#include "../lib/q3map_common.h"
#include "../../external/cJSON/cJSON.h"
#include <getopt.h>

typedef struct {
    char *input_file;
    char *output_file;
    float min_importance;
    qboolean use_stdin;
} Options;

void parse_args(int argc, char **argv, Options *opts);
char *read_file(const char *filename);
char *read_stdin(void);
int parse_entity(cJSON *json, entity_t *entity);
void write_entity(FILE *f, entity_t *entity);

int main(int argc, char **argv) {
    Options opts = {NULL, NULL, 0.0f, qfalse};
    char *json_str;
    cJSON *root, *entities_array, *entity_json;
    entity_t entity;
    FILE *output;
    int count = 0, skipped = 0;

    // Parse command line
    parse_args(argc, argv, &opts);

    // Read JSON input
    if (opts.use_stdin) {
        fprintf(stderr, "Reading from stdin...\n");
        json_str = read_stdin();
    } else {
        fprintf(stderr, "Reading from %s...\n", opts.input_file);
        json_str = read_file(opts.input_file);
    }

    if (!json_str) {
        fprintf(stderr, "Error: Failed to read input\n");
        return 1;
    }

    // Parse JSON
    root = cJSON_Parse(json_str);
    free(json_str);

    if (!root) {
        fprintf(stderr, "Error: Failed to parse JSON\n");
        return 1;
    }

    // Get entities array
    entities_array = cJSON_GetObjectItem(root, "entities");
    if (!entities_array || !cJSON_IsArray(entities_array)) {
        fprintf(stderr, "Error: JSON must have 'entities' array\n");
        cJSON_Delete(root);
        return 1;
    }

    // Open output
    if (opts.output_file) {
        output = fopen(opts.output_file, "w");
        if (!output) {
            fprintf(stderr, "Error: Cannot create %s\n", opts.output_file);
            cJSON_Delete(root);
            return 1;
        }
    } else {
        output = stdout;
    }

    // Write header
    fprintf(output, "// Generated by q3entity - %d entities\n\n",
            cJSON_GetArraySize(entities_array));

    // Process entities
    cJSON_ArrayForEach(entity_json, entities_array) {
        if (parse_entity(entity_json, &entity)) {
            if (entity.importance >= opts.min_importance) {
                write_entity(output, &entity);
                fprintf(output, "\n");
                count++;
            } else {
                skipped++;
            }
        }
    }

    if (opts.output_file) {
        fclose(output);
        fprintf(stderr, "Generated %d entities â†’ %s\n", count, opts.output_file);
    }

    cJSON_Delete(root);
    return 0;
}

void parse_args(int argc, char **argv, Options *opts) {
    int opt;
    while ((opt = getopt(argc, argv, "o:m:h")) != -1) {
        switch (opt) {
            case 'o': opts->output_file = optarg; break;
            case 'm': opts->min_importance = atof(optarg); break;
            case 'h':
                printf("Usage: %s [file.json] -o output.map\n", argv[0]);
                printf("  -o FILE    Output .map file\n");
                printf("  -m NUM     Min importance (0-1)\n");
                exit(0);
            default: exit(1);
        }
    }
    if (optind < argc) {
        opts->input_file = argv[optind];
    } else {
        opts->use_stdin = qtrue;
    }
}

char *read_file(const char *filename) {
    FILE *f = fopen(filename, "rb");
    if (!f) return NULL;
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    char *content = malloc(size + 1);
    if (content) {
        fread(content, 1, size, f);
        content[size] = '\0';
    }
    fclose(f);
    return content;
}

char *read_stdin(void) {
    size_t cap = 4096, size = 0;
    char *content = malloc(cap);
    if (!content) return NULL;
    while (!feof(stdin)) {
        if (size + 1024 > cap) {
            cap *= 2;
            content = realloc(content, cap);
            if (!content) return NULL;
        }
        size += fread(content + size, 1, 1024, stdin);
    }
    content[size] = '\0';
    return content;
}

int parse_entity(cJSON *json, entity_t *entity) {
    cJSON *item;

    item = cJSON_GetObjectItem(json, "id");
    if (item && cJSON_IsString(item))
        strncpy(entity->id, item->valuestring, 127);
    else return 0;

    item = cJSON_GetObjectItem(json, "label");
    if (item && cJSON_IsString(item))
        strncpy(entity->label, item->valuestring, 127);
    else strcpy(entity->label, entity->id);

    item = cJSON_GetObjectItem(json, "entity_type");
    if (item && cJSON_IsString(item))
        strncpy(entity->entity_type, item->valuestring, 31);
    else strcpy(entity->entity_type, "OBJECT");

    item = cJSON_GetObjectItem(json, "primitive");
    if (item && cJSON_IsString(item))
        strncpy(entity->primitive, item->valuestring, 31);
    else strcpy(entity->primitive, "BOX");

    item = cJSON_GetObjectItem(json, "position");
    if (item && cJSON_IsArray(item) && cJSON_GetArraySize(item) >= 3) {
        entity->position[0] = cJSON_GetArrayItem(item, 0)->valuedouble;
        entity->position[1] = cJSON_GetArrayItem(item, 1)->valuedouble;
        entity->position[2] = cJSON_GetArrayItem(item, 2)->valuedouble;
    } else VectorClear(entity->position);

    item = cJSON_GetObjectItem(json, "scale");
    if (item && cJSON_IsArray(item) && cJSON_GetArraySize(item) >= 3) {
        entity->scale[0] = cJSON_GetArrayItem(item, 0)->valuedouble;
        entity->scale[1] = cJSON_GetArrayItem(item, 1)->valuedouble;
        entity->scale[2] = cJSON_GetArrayItem(item, 2)->valuedouble;
    } else entity->scale[0] = entity->scale[1] = entity->scale[2] = 1.0f;

    item = cJSON_GetObjectItem(json, "rotation");
    if (item && cJSON_IsArray(item) && cJSON_GetArraySize(item) >= 3) {
        entity->rotation[0] = cJSON_GetArrayItem(item, 0)->valuedouble;
        entity->rotation[1] = cJSON_GetArrayItem(item, 1)->valuedouble;
        entity->rotation[2] = cJSON_GetArrayItem(item, 2)->valuedouble;
    } else VectorClear(entity->rotation);

    item = cJSON_GetObjectItem(json, "importance");
    entity->importance = (item && cJSON_IsNumber(item)) ? item->valuedouble : 0.5f;

    return 1;
}

void write_entity(FILE *f, entity_t *entity) {
    vec3_t qpos;
    float r, g, b;
    const char *model;

    WorldToQuake(entity->position, qpos);
    ImportanceToColor(entity->importance, &r, &g, &b);
    model = GetModelForEntityType(entity->entity_type);

    fprintf(f, "// %s (%s)\n", entity->label, entity->entity_type);
    fprintf(f, "{\n");
    fprintf(f, "\"classname\" \"misc_model\"\n");
    fprintf(f, "\"model\" \"%s\"\n", model);
    fprintf(f, "\"origin\" \"%.1f %.1f %.1f\"\n", qpos[0], qpos[1], qpos[2]);
    fprintf(f, "\"modelscale\" \"%.2f\"\n", entity->scale[0]);
    fprintf(f, "\"_color\" \"%.2f %.2f %.2f\"\n", r, g, b);
    fprintf(f, "\"targetname\" \"%s\"\n", entity->label);
    fprintf(f, "}\n");
}
